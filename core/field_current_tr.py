# filename: field_current_tr.py
#
# The following helper functions provide the calculation of magnetic fields and associated currents,
# using a cubic model for the relation between the current and magnetic field (and vice versa).
#
# Author: Maxwell Guerne-Kieferndorf (QZabre)
#            gmaxwell at student.ethz.ch
#
# Date: 09.10.2020
# latest update: 23.03.2021

# Standard library imports 
import pickle
import numpy as np
import pandas as pd
from sklearn import linear_model
from sklearn.preprocessing import PolynomialFeatures


def computeMagneticFieldVector(magnitude: float, theta: float, phi: float):
    """
    Compute the cartesian coordinates of a magnetic field with an arbitrary direction
    and an arbitrary magnitude, given the spherical coordinates.

    Args:
        magnitude: of the B-field, units: [mT]
        theta: polar angle, between desired field direction and z axis
        phi: azimuthal angle (angle measured counter clockwise from the x axis)

    Returns:
        Vector of 3 B field components (Bx,By,Bz), as a np.array, units: [mT]
    """

    x = np.sin(np.radians(theta)) * np.cos(np.radians(phi))
    y = np.sin(np.radians(theta)) * np.sin(np.radians(phi))
    z = np.cos(np.radians(theta))

    unitVector = np.array((x, y, z))
    unitVector = unitVector / np.linalg.norm(unitVector)

    return np.around(unitVector * magnitude, 3)


def computeCoilCurrents(B_fieldVector, 
                model_filename = r'fitting_parameters\model_QSM_poly3_nooffset_B2I.sav'):
    """
    Compute coil currents [mA] required to generate the desired magnetic field vector.
    Model derived from calibration measurements and saved as file

    Args:
    - B_fieldVector (1d-ndarray of length 3): B-field in cartesian coordinates and in mT
    - mode_filename (str): valid path of the model use to transform currents into magnetic fields

    Return: 
    - currVector (1d-ndarray of length 3): Estimated current values [A] that are required 
    to generate B_fieldVector 
    """
    # load the model from disk
    [loaded_model, loaded_poly] = pickle.load(open(model_filename, 'rb'))

    # preprocess test vectors, st. they have correct shape for model
    B_fieldVector_reshape = B_fieldVector.reshape((1, 3))
    test_vectors_ = loaded_poly.fit_transform(B_fieldVector_reshape)

    # estimate prediction of required currents
    currVector = loaded_model.predict(test_vectors_)
    currVector = currVector.reshape(3)      # [mA]
    currVector = np.round(currVector, 3)    # round to nearest milliamp

    return currVector


def computeMagField(currVector,
                    model_filename = r'fitting_parameters\model_QSM_poly3_nooffset_I2B.sav'):
    """
    Compute magnetic field vector generated by the currents.

    Args:
    - currVector (1d-ndarray of length 3): current values [A] of coils
    - mode_filename (str): valid path of the model use to transform currents into magnetic fields

    Returns:
    - B_fieldVector (1d-ndarray of length 3): B-field generated by the applied currents 
    in Cartesian coordinates: (Bx,By,Bz). Units: [mT]
    """
    # load the model from disk
    [loaded_model, loaded_poly] = pickle.load(open(model_filename, 'rb'))

    # preprocess test vectors, st. they have correct shape for model
    currVector = currVector  # [A]
    currVector_reshape = currVector.reshape((1, 3))
    test_vectors_ = loaded_poly.fit_transform(currVector_reshape)

    # estimate prediction of generated field
    B_fieldVector = loaded_model.predict(test_vectors_)

    return np.round(B_fieldVector.reshape(3), 3)


if __name__ == '__main__':
    # ------------------------Testing area--------------------------
    B1 = computeMagneticFieldVector(theta=90, phi=90, magnitude=50)
    print(f'Bx = {B1[0]}mT, By = {B1[1]}mT, Bz = {B1[2]}mT')
    currents = computeCoilCurrents(B1)
    print(f'I1 = {currents[0]}A, I2 = {currents[1]}A, I3 = {currents[2]}A')
    B2 = computeMagField(currents)
    print(f'Bx = {B2[0]:.3f}mT, By = {B2[1]:.3f}mT, Bz = {B2[2]:.3f}mT')
