import numpy as np
import enum
import pickle
from pyqtgraph.parametertree import Parameter
from PyQt5.QtCore import QObject
from PyQt5.QtCore import pyqtSignal


@enum.unique
class MAGNET_STATE(enum.Enum):
    """Magnet power states.
    
    """
    ON = 1
    OFF = 2

class MagnetBackendBase(QObject):
    """Vector magnet backend base class.
    
    """
    # Event: current change.
    on_current_change_all = pyqtSignal(np.ndarray)
    on_current_change_single = pyqtSignal(float, int)

    # Event: current change.
    on_field_status_change = pyqtSignal(MAGNET_STATE)

    # changeable parameters
    filename_model_B2I = 'model_QSM_poly3_nooffset_B2I.sav'
    filename_model_I2B = 'model_QSM_poly3_nooffset_I2B.sav'

    def get_currents(self) -> np.ndarray:
        """Returns currents of power supplies.

        """
        raise NotImplementedError()


    def set_currents(self, values: np.ndarray):
        """Sets the currents of power supplies.

        :param values: Current values to be set.
        """
        raise NotImplementedError()


    def enable_field(self):
        """Enables magnetic field.

        """
        raise NotImplementedError()


    def disable_field(self):
        """Disables magnetic field.

        """
        raise NotImplementedError()


    def get_magnet_status(self) -> MAGNET_STATE:
        """Returns status of magnet.

        """
        raise NotImplementedError()

    def set_demagnetization_flag(self, flag: bool):
        """Sets the demagnetization flag.

        """
        raise NotImplementedError()

    @staticmethod
    def spherical_to_cartesian(spherical_coords: np.ndarray) -> np.ndarray:
        """Compute the Cartesian coordinates from spherical coordinates.

        :param spherical_coords: Magnetic field in spherical coordinates to be set: 
        (magnitude [mT], polar angle wrt. z axis [degrees], azimuthal angle clockwise wrt. x-axis [degrees])

        :returns: vector in Cartesian coordinates [Bx, By, Bz]
        :rtype: np.ndarray
        """
        # explicitly define spherical coordinates to prevent misconfusions
        magnitude, theta, phi = spherical_coords

        cartesian_vector = np.array([  np.sin(np.radians(theta)) * np.cos(np.radians(phi)),
                                        np.sin(np.radians(theta)) * np.sin(np.radians(phi)),
                                        np.cos(np.radians(theta))])

        cartesian_vector = magnitude* cartesian_vector / np.linalg.norm(cartesian_vector)
        return np.around(cartesian_vector, 3)

    def _compute_coil_currents(self, magnetic_field_vector: np.ndarray) -> np.ndarray:
        """Compute coil currents [mA] required to generate the desired magnetic field vector.
        Model derived from calibration measurements and saved as file.

        :param magnetic_field_vector: field vector in Cartesian coordinates and in mT
        :type magnetic_field_vector: 1d np.ndarray of length 3
        
        :returns: current vectors [A] required to generate magnetic_field_vector 
        :rtype: 1d np.ndarray of length 3
        """
        # load the model from disk
        filepath = f'./fitting_parameters/{self.filename_model_B2I}'
        [loaded_model, loaded_poly] = pickle.load(open(filepath, 'rb'))

        # preprocess test vectors, st. they have correct shape for model
        input_vector_ = loaded_poly.fit_transform(magnetic_field_vector.reshape((1, 3)))

        # estimate prediction of required currents
        current_vector = loaded_model.predict(input_vector_)
        
        return np.round(current_vector.reshape(3), 3)


    def _compute_magnetic_field(self, current_vector: np.ndarray) -> np.ndarray:
        """Compute magnetic field vector generated by the currents.

        :param current_vector: current values [A] of coils
        :type current_vector: 1d np.ndarray of length 3

        :returns: expected field vector [mT] in Cartesian coordinates generated by the applied currents 
        :rtype: 1d np.ndarray of length 3
        """
        # load the model from disk
        filepath = f'./fitting_parameters/{self.filename_model_I2B}'
        [loaded_model, loaded_poly] = pickle.load(open(filepath, 'rb'))

        # preprocess test vectors, st. they have correct shape for model
        input_vector_ = loaded_poly.fit_transform(current_vector.reshape((1, 3)))

        # estimate prediction of generated field
        magnetic_field_vector = loaded_model.predict(input_vector_)

        return np.round(magnetic_field_vector.reshape(3), 3)

    def get_target_field(self) -> np.ndarray:
        """Returns current setpoint of magnetic field.

        """
        return self._setpoint_fields

    def set_target_field(self, spherical_values: np.ndarray):
        """Sets the target point of magnetic field.

        :param spherical_values: Magnetic field in spherical coordinates to be set: 
        (magnitude [mT], polar angle wrt. z axis [degrees], azimuthal angle clockwise wrt. x-axis [degrees])
        """
        cartesian_values = self.spherical_to_cartesian(spherical_values)
        if np.any(self._setpoint_fields != cartesian_values):  
            # estimate required currents
            required_currents = self._compute_coil_currents(cartesian_values)

            # set required currents
            self.set_currents(required_currents)
            self._setpoint_fields = cartesian_values